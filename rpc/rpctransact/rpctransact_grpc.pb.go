// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpctransact

import (
	context "context"

	exec "github.com/hyperledger/burrow/execution/exec"
	txs "github.com/hyperledger/burrow/txs"
	payload "github.com/hyperledger/burrow/txs/payload"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TransactClient is the client API for Transact service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransactClient interface {
	// Broadcast a transaction to the mempool - if the transaction is not signed signing will be attempted server-side
	// and wait for it to be included in block
	BroadcastTxSync(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Broadcast a transaction to the mempool - if the transaction is not signed signing will be attempted server-side
	BroadcastTxAsync(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*txs.Receipt, error)
	// Sign transaction server-side
	SignTx(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*TxEnvelope, error)
	// Formulate a transaction from a Payload and retrun the envelop with the Tx bytes ready to sign
	FormulateTx(ctx context.Context, in *payload.Any, opts ...grpc.CallOption) (*TxEnvelope, error)
	// Formulate and sign a CallTx transaction signed server-side and wait for it to be included in a block, retrieving response
	CallTxSync(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Formulate and sign a CallTx transaction signed server-side
	CallTxAsync(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*txs.Receipt, error)
	// Perform a 'simulated' call of a contract against the current committed EVM state without any changes been saved
	// and wait for the transaction to be included in a block
	CallTxSim(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Perform a 'simulated' execution of provided code against the current committed EVM state without any changes been saved
	CallCodeSim(ctx context.Context, in *CallCodeParam, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Formulate a SendTx transaction signed server-side and wait for it to be included in a block, retrieving response
	SendTxSync(ctx context.Context, in *payload.SendTx, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Formulate and  SendTx transaction signed server-side
	SendTxAsync(ctx context.Context, in *payload.SendTx, opts ...grpc.CallOption) (*txs.Receipt, error)
	// Formulate a NameTx signed server-side and wait for it to be included in a block returning the registered name
	NameTxSync(ctx context.Context, in *payload.NameTx, opts ...grpc.CallOption) (*exec.TxExecution, error)
	// Formulate a NameTx signed server-side
	NameTxAsync(ctx context.Context, in *payload.NameTx, opts ...grpc.CallOption) (*txs.Receipt, error)
}

type transactClient struct {
	cc grpc.ClientConnInterface
}

func NewTransactClient(cc grpc.ClientConnInterface) TransactClient {
	return &transactClient{cc}
}

func (c *transactClient) BroadcastTxSync(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/BroadcastTxSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) BroadcastTxAsync(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*txs.Receipt, error) {
	out := new(txs.Receipt)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/BroadcastTxAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) SignTx(ctx context.Context, in *TxEnvelopeParam, opts ...grpc.CallOption) (*TxEnvelope, error) {
	out := new(TxEnvelope)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/SignTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) FormulateTx(ctx context.Context, in *payload.Any, opts ...grpc.CallOption) (*TxEnvelope, error) {
	out := new(TxEnvelope)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/FormulateTx", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) CallTxSync(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/CallTxSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) CallTxAsync(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*txs.Receipt, error) {
	out := new(txs.Receipt)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/CallTxAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) CallTxSim(ctx context.Context, in *payload.CallTx, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/CallTxSim", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) CallCodeSim(ctx context.Context, in *CallCodeParam, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/CallCodeSim", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) SendTxSync(ctx context.Context, in *payload.SendTx, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/SendTxSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) SendTxAsync(ctx context.Context, in *payload.SendTx, opts ...grpc.CallOption) (*txs.Receipt, error) {
	out := new(txs.Receipt)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/SendTxAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) NameTxSync(ctx context.Context, in *payload.NameTx, opts ...grpc.CallOption) (*exec.TxExecution, error) {
	out := new(exec.TxExecution)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/NameTxSync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactClient) NameTxAsync(ctx context.Context, in *payload.NameTx, opts ...grpc.CallOption) (*txs.Receipt, error) {
	out := new(txs.Receipt)
	err := c.cc.Invoke(ctx, "/rpctransact.Transact/NameTxAsync", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactServer is the server API for Transact service.
// All implementations must embed UnimplementedTransactServer
// for forward compatibility
type TransactServer interface {
	// Broadcast a transaction to the mempool - if the transaction is not signed signing will be attempted server-side
	// and wait for it to be included in block
	BroadcastTxSync(context.Context, *TxEnvelopeParam) (*exec.TxExecution, error)
	// Broadcast a transaction to the mempool - if the transaction is not signed signing will be attempted server-side
	BroadcastTxAsync(context.Context, *TxEnvelopeParam) (*txs.Receipt, error)
	// Sign transaction server-side
	SignTx(context.Context, *TxEnvelopeParam) (*TxEnvelope, error)
	// Formulate a transaction from a Payload and retrun the envelop with the Tx bytes ready to sign
	FormulateTx(context.Context, *payload.Any) (*TxEnvelope, error)
	// Formulate and sign a CallTx transaction signed server-side and wait for it to be included in a block, retrieving response
	CallTxSync(context.Context, *payload.CallTx) (*exec.TxExecution, error)
	// Formulate and sign a CallTx transaction signed server-side
	CallTxAsync(context.Context, *payload.CallTx) (*txs.Receipt, error)
	// Perform a 'simulated' call of a contract against the current committed EVM state without any changes been saved
	// and wait for the transaction to be included in a block
	CallTxSim(context.Context, *payload.CallTx) (*exec.TxExecution, error)
	// Perform a 'simulated' execution of provided code against the current committed EVM state without any changes been saved
	CallCodeSim(context.Context, *CallCodeParam) (*exec.TxExecution, error)
	// Formulate a SendTx transaction signed server-side and wait for it to be included in a block, retrieving response
	SendTxSync(context.Context, *payload.SendTx) (*exec.TxExecution, error)
	// Formulate and  SendTx transaction signed server-side
	SendTxAsync(context.Context, *payload.SendTx) (*txs.Receipt, error)
	// Formulate a NameTx signed server-side and wait for it to be included in a block returning the registered name
	NameTxSync(context.Context, *payload.NameTx) (*exec.TxExecution, error)
	// Formulate a NameTx signed server-side
	NameTxAsync(context.Context, *payload.NameTx) (*txs.Receipt, error)
	mustEmbedUnimplementedTransactServer()
}

// UnimplementedTransactServer must be embedded to have forward compatible implementations.
type UnimplementedTransactServer struct {
}

func (UnimplementedTransactServer) BroadcastTxSync(context.Context, *TxEnvelopeParam) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTxSync not implemented")
}
func (UnimplementedTransactServer) BroadcastTxAsync(context.Context, *TxEnvelopeParam) (*txs.Receipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastTxAsync not implemented")
}
func (UnimplementedTransactServer) SignTx(context.Context, *TxEnvelopeParam) (*TxEnvelope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignTx not implemented")
}
func (UnimplementedTransactServer) FormulateTx(context.Context, *payload.Any) (*TxEnvelope, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FormulateTx not implemented")
}
func (UnimplementedTransactServer) CallTxSync(context.Context, *payload.CallTx) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTxSync not implemented")
}
func (UnimplementedTransactServer) CallTxAsync(context.Context, *payload.CallTx) (*txs.Receipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTxAsync not implemented")
}
func (UnimplementedTransactServer) CallTxSim(context.Context, *payload.CallTx) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallTxSim not implemented")
}
func (UnimplementedTransactServer) CallCodeSim(context.Context, *CallCodeParam) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallCodeSim not implemented")
}
func (UnimplementedTransactServer) SendTxSync(context.Context, *payload.SendTx) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTxSync not implemented")
}
func (UnimplementedTransactServer) SendTxAsync(context.Context, *payload.SendTx) (*txs.Receipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendTxAsync not implemented")
}
func (UnimplementedTransactServer) NameTxSync(context.Context, *payload.NameTx) (*exec.TxExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NameTxSync not implemented")
}
func (UnimplementedTransactServer) NameTxAsync(context.Context, *payload.NameTx) (*txs.Receipt, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NameTxAsync not implemented")
}
func (UnimplementedTransactServer) mustEmbedUnimplementedTransactServer() {}

// UnsafeTransactServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransactServer will
// result in compilation errors.
type UnsafeTransactServer interface {
	mustEmbedUnimplementedTransactServer()
}

func RegisterTransactServer(s grpc.ServiceRegistrar, srv TransactServer) {
	s.RegisterService(&Transact_ServiceDesc, srv)
}

func _Transact_BroadcastTxSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxEnvelopeParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).BroadcastTxSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/BroadcastTxSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).BroadcastTxSync(ctx, req.(*TxEnvelopeParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_BroadcastTxAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxEnvelopeParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).BroadcastTxAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/BroadcastTxAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).BroadcastTxAsync(ctx, req.(*TxEnvelopeParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_SignTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxEnvelopeParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).SignTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/SignTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).SignTx(ctx, req.(*TxEnvelopeParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_FormulateTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).FormulateTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/FormulateTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).FormulateTx(ctx, req.(*payload.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_CallTxSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.CallTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).CallTxSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/CallTxSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).CallTxSync(ctx, req.(*payload.CallTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_CallTxAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.CallTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).CallTxAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/CallTxAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).CallTxAsync(ctx, req.(*payload.CallTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_CallTxSim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.CallTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).CallTxSim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/CallTxSim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).CallTxSim(ctx, req.(*payload.CallTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_CallCodeSim_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallCodeParam)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).CallCodeSim(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/CallCodeSim",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).CallCodeSim(ctx, req.(*CallCodeParam))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_SendTxSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.SendTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).SendTxSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/SendTxSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).SendTxSync(ctx, req.(*payload.SendTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_SendTxAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.SendTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).SendTxAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/SendTxAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).SendTxAsync(ctx, req.(*payload.SendTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_NameTxSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.NameTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).NameTxSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/NameTxSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).NameTxSync(ctx, req.(*payload.NameTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transact_NameTxAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(payload.NameTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactServer).NameTxAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/rpctransact.Transact/NameTxAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactServer).NameTxAsync(ctx, req.(*payload.NameTx))
	}
	return interceptor(ctx, in, info, handler)
}

// Transact_ServiceDesc is the grpc.ServiceDesc for Transact service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Transact_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "rpctransact.Transact",
	HandlerType: (*TransactServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BroadcastTxSync",
			Handler:    _Transact_BroadcastTxSync_Handler,
		},
		{
			MethodName: "BroadcastTxAsync",
			Handler:    _Transact_BroadcastTxAsync_Handler,
		},
		{
			MethodName: "SignTx",
			Handler:    _Transact_SignTx_Handler,
		},
		{
			MethodName: "FormulateTx",
			Handler:    _Transact_FormulateTx_Handler,
		},
		{
			MethodName: "CallTxSync",
			Handler:    _Transact_CallTxSync_Handler,
		},
		{
			MethodName: "CallTxAsync",
			Handler:    _Transact_CallTxAsync_Handler,
		},
		{
			MethodName: "CallTxSim",
			Handler:    _Transact_CallTxSim_Handler,
		},
		{
			MethodName: "CallCodeSim",
			Handler:    _Transact_CallCodeSim_Handler,
		},
		{
			MethodName: "SendTxSync",
			Handler:    _Transact_SendTxSync_Handler,
		},
		{
			MethodName: "SendTxAsync",
			Handler:    _Transact_SendTxAsync_Handler,
		},
		{
			MethodName: "NameTxSync",
			Handler:    _Transact_NameTxSync_Handler,
		},
		{
			MethodName: "NameTxAsync",
			Handler:    _Transact_NameTxAsync_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpctransact.proto",
}
